9/*
. Program written to allow;
    (A) Manual creation of a vector list (e.g. Place ordered points by hand to provide a vector lines usable 
        by the vectrex; an image can be overlayed behind to essentially 'trace' it)
    (B) Automatic creation of a vector list from an image provided
. The generated vector list will be a set of relative vectors applicable to the 'lines(nlines, list)' function 
    declared in vectrex/bios.h, as provided by CMOC
. Another list will also be provided which specifies the indices in the vector list where the line should not be 
    drawn, just the beam moved (so the image does not have to completely connected)


###
### Do greyscale dots method -> also means you can get a fast path to draw image too
### For both methods, track the intensity as well to get a better greyscale image with details
###
*/

PrintWriter output;
String creationMode = "NULL";
int vectrexHalfDimMax = 128;        // +-128 in each direction (essentially percentage of screen width using 8 bit signed values)
float personalScaleFactor = 1.0;    // Additional scale factor to manual alter magnitude of vectors calculated by this factor (shrink or expand ouput result further)

PImage referenceImage = null;
PVector referenceDim = new PVector(0,0);
float referenceScaleRate = 0.01;    // Percentage change in each dim each frame a change occurs
int referenceRescale = 0;   // 0=Unaffected, 1 = SizeIncrease, -1=SizeDecrease

Boolean toggleAutoDotsCalc = true;

Boolean toggleControls = true;
Boolean toggleVectorNodes = true;
Boolean toggleVectors = true;
Boolean toggleReference = true;
Boolean toggleOrigin = true;
PVector origin = new PVector(0,0);
ArrayList<PVector> vectorNodes = new ArrayList<PVector>();      // Positions of nodes
ArrayList<Integer> skippedNodes = new ArrayList<Integer>();     // Indices in vectorNodes of skipped nodes
ArrayList<PVector> dotNodes = new ArrayList<PVector>();         // (x, y, intensity) of dots placed

int backgroundColor = 255;

// Setup
void setup() {
    creationMode = "AUTO_DOTS"; //MANUAL
    size(800, 800);
    background(backgroundColor);

    try {
        referenceImage = loadImage("referenceImage.png");
        referenceDim = new PVector(referenceImage.width, referenceImage.height);
    } catch(Exception e) {
        println("Invalid reference image; expecting file of format 'referenceImage.png' in /data folder");
    }

    switch(creationMode) {
        case "MANUAL":
            //pass
            break;
        case "AUTO":
            //pass
            break;
        case "AUTO_DOTS":
            toggleVectors = false;
            calculateAutoDots();
            break;
    }
}

void draw() {
    background(backgroundColor);
    displayGeneralMode();
    switch(creationMode) {
        case "MANUAL":
            displayManualMode();
            break;
        case "AUTO":
            displayAutoMode();
            break;
        case "AUTO_DOTS":
            if(toggleAutoDotsCalc){calculateAutoDots();}
            displayAutoDotsMode();
            break;
    }
}

void keyPressed() {
    switch(creationMode) {
        case "MANUAL":
            if(key == '1') {    // Place origin
                origin = new PVector(mouseX, mouseY);
                println("* Origin placed");
            }
            if(key == '2') {    // Place vectorNode
                vectorNodes.add( new PVector(mouseX, mouseY) );
                println("* VectorNode placed");
            }
            if(key == '3') {    // Remove last placed  vectorNode
                if(vectorNodes.size() > 0) { vectorNodes.remove( vectorNodes.size()-1 );println("* VectorNode removed"); }
            }
            if(key == '4') {    // Mark latest node as a skipped node
                skippedNodes.add( vectorNodes.size()-1 );
                println("* Skipped node set");
            }
            if(key == '5') {    // Remove latest marked skipped node
                if(skippedNodes.size() > 0) { skippedNodes.remove( skippedNodes.size()-1 );println("* Skipped node removed"); }
            }
            break;
        case "AUTO":
            //pass
            break;
        case "AUTO_DOTS":
            if(key == 'z') { toggleAutoDotsCalc = !toggleAutoDotsCalc; }
            break;
    }
    if(key == 'a') {
        printVectorArrayOuputs();
    }
    // Toggles
    if(key == '6') { toggleControls = !toggleControls; }
    if(key == '7') { toggleVectorNodes = !toggleVectorNodes; }
    if(key == '8') { toggleVectors = !toggleVectors; }
    if(key == '9') { toggleReference = !toggleReference; }
    if(key == '0') { toggleOrigin = !toggleOrigin; }
    if(key == 'w') { referenceRescale = 1; }
    if(key == 's') { referenceRescale = -1; }
    if(key == 'q') { personalScaleFactor -= 0.05; }
    if(key == 'e') { personalScaleFactor += 0.05; }
}
void keyReleased() {
    if(key == 'w') { referenceRescale = 0; }
    if(key == 's') { referenceRescale = 0; }
}


// General methods
void displayGeneralMode() {
    /*
    . Displays all relevant to all modes for the program
    . This includes;
        . Background reference image
        . Manually/Automatically chosen origin position (important for vectrex display only)
        . Manually placed vector nodes + skip nodes
        . The resulting output vectors
        . Hotkeys to toggle each of these layers
    */
    if(toggleReference) {displayReferenceImage();}
    if(toggleOrigin) {displayOrigin();}
    if(toggleVectorNodes) {displayVectorNodes(true);}
    if(toggleVectorNodes) {displaySkippedNodes();}
    if(toggleVectors) {displayVectorOutput();}
    if(toggleControls) {displayControls();}
}
void displayReferenceImage() {
    /*
    . Displays the loaded reference if image if possible
    . Displays nothing if not loaded
    */
    if(referenceImage!=null) {
        referenceDim.x += referenceDim.x*referenceScaleRate*referenceRescale;
        referenceDim.y += referenceDim.y*referenceScaleRate*referenceRescale;
        image(referenceImage, 0, 0, referenceDim.x, referenceDim.y);
        filter(GRAY);
    }
}
void displayOrigin() {
    pushStyle();
    fill(0,100,0);
    noStroke();
    ellipse(origin.x, origin.y, 10, 10);
    popStyle();
}
void displayVectorNodes(Boolean includeOrder) {
    /*
    . Displays the nodes used to connect the vectors to produce the image
    . Vector nodes will connect to subsequent vector nodes to form vectors, but will NOT form a vector if the following node is a 'skipped node' (marked in a separate list)
    */
    for(int i=0; i<vectorNodes.size(); i++) {
        pushStyle();
        fill(0,0,0);
        noStroke();
        ellipse(vectorNodes.get(i).x, vectorNodes.get(i).y, 10, 10);

        if(includeOrder) {
            text(i, vectorNodes.get(i).x, vectorNodes.get(i).y-10);
        }

        popStyle();
    }
}
void displaySkippedNodes() {
    /*
    . Displays the nodes used to connect the vectors to produce the image
    . Vector nodes will connect to subsequent vector nodes to form vectors, but will NOT form a vector if the following node is a 'skipped node' (marked in a separate list)
    */
    for(int i=0; i<skippedNodes.size(); i++) {
        if(skippedNodes.get(i) < vectorNodes.size()) {
            pushStyle();
            fill(200,0,0);
            noStroke();
            ellipse(vectorNodes.get( skippedNodes.get(i) ).x, vectorNodes.get( skippedNodes.get(i) ).y, 15, 15);
            popStyle();
        }
    }
}
void displayVectorOutput() {
    /*
    . Displays the actual vectors connecting each node according to the parameters given
    . This should reflect the output
    */
    if(vectorNodes.size() > 1) {    // If at least 1 vector can be formed
        pushStyle();
        noFill();
        stroke(0,0,50);
        strokeWeight(2);
        for(int i=1; i<vectorNodes.size(); i++) {
            Boolean isSkippedNode = false;
            for(int j=0; j<skippedNodes.size(); j++) {
                if(skippedNodes.get(j) == i) {
                    isSkippedNode = true;
                    break;
                }
            }
            if(!isSkippedNode) {    // If not a skipped node, connect to the prior node
                line(
                    vectorNodes.get(i-1).x, vectorNodes.get(i-1).y, 
                    vectorNodes.get(i  ).x, vectorNodes.get(i  ).y
                );
            }
        }
        popStyle();
    }
}
void displayControls() {
    /*
    . Displays the general hotkeys for the program
    */
    float textSize = 15;
    pushStyle();
    fill(0,0,0);
    textSize(textSize);
    text("1 = Place origin", 0, 1*textSize);
    text("2 = Place  vectorNode", 0, 2*textSize);
    text("3 = Remove vectorNode", 0, 3*textSize);
    text("4 = Place  skippedNode", 0, 4*textSize);
    text("5 = Remove skippedNode", 0, 5*textSize);
    text("6 = Toggle controls", 0, 6*textSize);
    text("7 = Toggle vectorNodes", 0, 7*textSize);
    text("8 = Toggle vectors", 0, 8*textSize);
    text("9 = Toggle referenceImage", 0, 9*textSize);
    text("0 = Toggle origin", 0, 10*textSize);
    text("---", 0, 11*textSize);
    text("a = Get vector array output", 0, 12*textSize);
    text("w = Increase reference size", 0, 13*textSize);
    text("s = Decrease reference size", 0, 14*textSize);
    text("q = Decrease personalScaleFactor", 0, 15*textSize);
    text("e = Increase personalScaleFactor", 0, 16*textSize);
    text("personalScaleFactor = "+str(personalScaleFactor), 0, 17*textSize);
    popStyle();
}

void printVectorArrayOuputs() {
    /*
    . Print to console the arrays needed (in C format) for the vectrex lines() function to draw the image given
    . ** Note; The y coordinates are flipped due to processing using an XY axis of (RIGHT, UP) as (+, -), whereas the vectrex uses a more traditional (+, +)
    */
    float vectrexScaleFactor = 2.0*vectrexHalfDimMax/width;   // Convert from processing pixel based units to vectrex coordinates
    // + Use personalScaleFactor

    output = createWriter("arrayOutputs.txt"); 

    output.println("=== ORIGIN/MOVE START ===");
    if(vectorNodes.size() > 0) { output.println("move("+str(int( (vectorNodes.get(0).x-origin.x)*vectrexScaleFactor*personalScaleFactor ))+","+str(-int( (vectorNodes.get(0).y-origin.y)*vectrexScaleFactor*personalScaleFactor ))+");"); }
    output.println("=== ORIGIN/MOVE END ===");
    
    output.println("=== VECTOR NODES START ===");
    output.println("const int8_t vectors_array["+str(int(2*vectorNodes.size()))+"] = {");
    if(vectorNodes.size() > 1) {    // If you have at least 1 vector (e.g. 2 points -> doesn't account for skips at this minimum; *Be Careful*)
        for(int i=1; i<vectorNodes.size(); i++) {
            output.println( "  "+str(int( (vectorNodes.get(i).x-vectorNodes.get(i-1).x)*vectrexScaleFactor*personalScaleFactor ))+", "+str(-int( (vectorNodes.get(i).y-vectorNodes.get(i-1).y)*vectrexScaleFactor*personalScaleFactor ))+", " );
        }
    }
    output.println("};");
    output.println("=== VECTOR NODES END ===");

    output.println("=== SKIPPED NODES START ===");
    output.println("const uint8_t skipped_array["+str(int(skippedNodes.size()))+"] = {");
    for(int j=0; j<skippedNodes.size(); j++) {
        output.println( "  "+str(int(skippedNodes.get(j)))+", " );
    }
    output.println("};");
    output.println("=== SKIPPED NODES END ===");

    output.println("=== DOT NODES START ===");
    output.println("const int8_t dots_array["+str(int(2*dotNodes.size()))+"] = {");
    if(dotNodes.size() > 1) {    // If you have at least 1 vector (e.g. 2 points -> doesn't account for skips at this minimum; *Be Careful*)
        for(int i=1; i<dotNodes.size(); i++) {
            output.println( "  "+str(int( (dotNodes.get(i).x-dotNodes.get(i-1).x)*vectrexScaleFactor*personalScaleFactor ))+", "+str(-int( (dotNodes.get(i).y-dotNodes.get(i-1).y)*vectrexScaleFactor*personalScaleFactor ))+", " );
        }
    }
    output.println("};");
    output.println("=== DOT NODES END ===");

    output.println("=== DOT NODE INTENSITY START ===");
    output.println("const int8_t dots_intensity_array["+str(int(dotNodes.size()))+"] = {");
    if(dotNodes.size() > 1) {    // If you have at least 1 vector (e.g. 2 points -> doesn't account for skips at this minimum; *Be Careful*)
        for(int i=1; i<dotNodes.size(); i++) {
            output.print( "  "+str(int( (dotNodes.get(i).z) ))+"," );
        }
    }
    output.println("};");
    output.println("=== DOT NODE INTENSITY END ===");

    output.flush(); // Writes the remaining data to the file
    output.close(); // Finishes the file
    println("=== Output Complete ===");
}


// Manual specific methods
void displayManualMode() {
    /*
    . Displays all relevant to the manual mode for the program
    . This includes;
        ...
    */
    //pass
}


// Automatic specific methods
void displayAutoMode() {
    /*
    . Displays all relevant to the auto mode for the program
    . This includes;
        ...
    */
    //pass
}


// Automatic dots specific methods
void displayAutoDotsMode() {
    displayDotNodes(false);
}
void displayDotNodes(Boolean includeOrder) {
    /*
    . Displays the nodes used to connect the vectors to produce the image
    . Vector nodes will connect to subsequent vector nodes to form vectors, but will NOT form a vector if the following node is a 'skipped node' (marked in a separate list)
    */
    for(int i=0; i<dotNodes.size(); i++) {
        pushStyle();
        fill( floor((255.0/7.0)*dotNodes.get(i).z) );
        noStroke();
        ellipse(dotNodes.get(i).x, dotNodes.get(i).y, 10, 10);

        if(includeOrder) {
            text(i, dotNodes.get(i).x, dotNodes.get(i).y-10);
        }

        popStyle();
    }
}
void calculateAutoDots() {
    int resolution = 10;
    int searchRadius = 3;
    loadPixels();
    dotNodes = new ArrayList<PVector>();

    // ###
    // ### SHOULD FLIP ORDER THEY ARE ADDED (E.G. FORWARD, THEN BACKWARDS, THEN FORWARDS, ...) EACH ITER TO GIVE SHORTER SNAKING PATH RATHER THAN LONGER ROUTE
    // ###
    for(int j=0; j<height; j+=resolution) {
        for(int i=0; i<width; i+=resolution) {
            // Average nearby pixel values
            float pixelValue = 0;
            for(int q=max(0, j-searchRadius); q<min(height, j+searchRadius); q++) {
                for(int p=max(0, i-searchRadius); p<min(width, i+searchRadius); p++) {
                    pixelValue += sqrt(pow(red(pixels[width*q +p]),2) + pow(green(pixels[width*q +p]),2) + pow(blue(pixels[width*q +p]),2));
                }
            }
            pixelValue /= ( min(height, j+searchRadius)-max(0, j-searchRadius) )*( min(width, i+searchRadius)-max(0, i-searchRadius) );
            float intensity = floor( (max(0, pixelValue-120)) / ((255.0-120.0)/7.0)); // Ranges from 0 to 7, with a cutoff brightness of 120
            // if(intensity > 0) {
            if(pixelValue <= 100.0) {
                // Change add index so list is ordered in a 'snake-ing' fashion, rather than always restarting back on the left (faster for the vectrex beam)
                if(floor(j/resolution) % 2 == 0) {
                    dotNodes.add(new PVector(i, j, intensity));     // Add to end => L to R
                } else {
                    dotNodes.add(0, new PVector(i, j, intensity));  // Add to start => R to L
                }
            }
        }
    }
    println("DOTS = "+str(dotNodes.size()));
}
